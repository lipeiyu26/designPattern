# 七大原则
## 开闭原则
 ** 一个软件实体如类，模块和函数应该对扩展开放，对修改关闭 
 ** 用抽象构建框架，用实现扩展细节 
 ** 优点：提高软件系统的可复用性及可维护性 
##  依赖倒置原则
 ** 高层模块不应该依赖底层模块，二者都应该依赖其抽象 
 ** 抽象不应该依赖细节，细节应该依赖抽象 
 ** 针对接口编程，不要针对实现编程 
 ** 优点：可以减少类之间的耦合性，提高系统稳定性，提高代码可读性和可维护性，可降低修改程序所造成的的风险  
##  单一职责原则
 ** 不要存在多于一个导致类变更的原因

 ** 一个接口，类，方法只负责一项职责
 ** 优点：降低类的复杂度 
 **      提高类的可读性 
 **      提高系统的可维护性 
 **      降低变更引起的风险
## 接口隔离原则
 ** 用多个专门的接口，而不是使用单一的总接口，客户端不应该依赖他不需要的接口

 ** 一个类对应一个类的依赖应该建立在最小的接口上

 ** 建立单一接口，不要建立庞大臃肿的接口

 ** 尽量细化接口，接口中的方法尽量少

 ** 注意适度原则，一定要适度

 ** 优点：符合我们常说的高内聚，低耦合的设计思想，

 **      从而使得类具有很好的可读性，可扩展性和可维护性
 
## 迪米特法则
 ** 一个对象应该对其他对象保持最少的了解，又叫最少知道原则

 ** 尽量降低类与类之间的耦合

 ** 优点：降低类之间的耦合

 ** 强调只和朋友交流，不和陌生人说话

 ** 朋友：出现在成员变量，方法的输入，输出参数中的类成为成员朋友类，而出现在方法体内部的类不属于朋友类
 
## 里氏替换原则
 ** 如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时。

 ** 程序P的行为没有发生变化，那么类型T2是类型T1的子类型

 ** 定义扩展：一个软件实体如果适用一个父类的话，那么一定适用于其子类，所有引用父类的地方必须能透明地使用其子类的对象，

 ** 子类对象能够替换父类对象，而程序逻辑不变

 ** 引申意义： 子类可以扩展父类的功能，但不能改变父类原有的功能

 ** 含义1：子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法

 ** 含义2：子类中可以增加自己特有的方法

 ** 含义3：当子类的方法重载父类的方法时，方法的前置条件（即方法的输入，入参）要比父类方法的输入参数更宽松

 ** 含义4：当子类的方法实现父类的方法时（重写，重载或实现抽象方法），方法的后置条件（级方法的输出，返回值）要比父类更严格或相等

 ** 优点1：约束继承泛滥，开闭原则的一种体现

 ** 优点2：加强程序的健壮性，同时变更时也可以做到非常好的兼容性，提高程序的维护性，扩展性，降低需求变更时引入的风险
 
## 组合复用原则
 ** 定义：尽量使用对象组合，聚合，而不是使用继承关系达到软件复用目的

 ** 聚合has-a和组合contains-a(继承is-a)

 ** 优点：可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少

## spring中用到的设计模式
 ** 工厂模式：BeanFactory

 ** 装饰器模式：BeanWrapper

 ** 代理模式：AopProxy

 ** 单例模式：ApplicationContext

 ** 委派模式：DispatcherServlet

 ** 策略模式：HandlerMapping

 ** 适配器模式：HandlerAdapter

 ** 模板方法模式：JdbcTemplate

 ** 观察者模式：ContextLoaderLinstener

## 简单工厂模式
 ** 简单工厂模式是指由一个工厂对象决定创建出哪一种产品类的实例

 ** 属于创建型模式，单他不属于GOF-23种设计模式

 ** 适用场景：工厂类负责创建的对象较少，客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关心

 ** 优点：只需要传入一个正确的参数，就可以获取你所需要的对象，无需知道其创建的细节

 ** 缺点：工厂类的职责相对过重，增加新的产品时需要修改工厂类的判断逻辑，违背开闭原则，不易于扩展过于复杂的产品结构

## 工厂方法模式
 ** 是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行

 ** 属于创建型设计模式

 ** 适用场景：创建对象需要大量重复的代码，客户端（应用层）不依赖于产品类实例如何创建对象，实现等细节，

 *** 一个类通过其子类来指定创建哪个对象

 ** 优点：用户只需要关心所需产品对应的工厂，无须关心创建细节

 *** 加入新产品符合开闭原则，提高了系统的可扩展性

 ** 缺点：类的个数容易过多，增加了代码结构的复杂度，增加了系统的抽象性和理解难度

## 抽象工厂模式
 ** 抽象工厂模式是指提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类

 ** 属于创建型设计模式

 ** 缺点：规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口，增加了系统的抽象性和理解难度

 ** 优点：具体产品在应用层代码隔离，无须关心创建细节，将一个系列的产品族统一到一起创建

 ** 应用场景：客户端（应用层）不依赖于产品类实例如何被创建，实现等细节；
 强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码；
 提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现

## 单例模式
** 单例模式是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点

** 隐藏其所有的构造方法

** 属于创建型模式

** 适用场景：确保任何情况下都绝对只有一个实例。ServletContext,ServletConfig,ApplicationContext,DBPool

** 单例模式常见写法：饿汉式单例，懒汉式单例，注册式单例，ThreadLoacl单例

** 优点：在内存中只有一个实例，减少了内存开销，可以避免对资源的多重占用，设置全局访问点，严格控制访问。

** 缺点：没有接口，扩展困难，如果要扩展单例对象，只有修改代码，没有其他途径

** 单例模式重点：1：私有化构造器，2：保证线程安全，3：延迟加载，4：防止序列化和反序列化破坏单例，5：防御反射攻击单例

## 原型模式
** 原型模式是指原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象，
** 调用者不需要知道任何创建细节，不调用构造函数，
** 属于创建型模式

** 适用场景：1：类初始化消耗资源较多，2：new产生的一个对象需要非常繁琐的过程（数据准备，访问权限等）3：构造函数比较复杂，4：循环体中生产大量对象树

** 缺点：必须配备克隆（或者可拷贝）方法，
**      对克隆复杂对象或对克隆出的对象进行复杂改造时，易带来风险，
**      深拷贝，浅拷贝要运用得当

## 建造者模式
** 建造者模式是将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示

** 特征：用户只需要指定需要建造的类型就可以获得对象，建造过程及细节不需要了解

** 属于创建型模式

** 使用场景：适用于创建对象需要很多步骤，但是步骤的顺序不一定固定，如果一个对象有非常复杂的内部结构（很多属性），
** 把复杂对象的创建和使用分离

** 优点：封装性好，创建和使用分离，扩展性好，建造类之间独立，一定程度上解耦

** 缺点：产生多余的Builder对象，产品内部发生变化，建造者都要修改，成本较大

** 建造者模式和工厂模式的区别

** 1：建造者模式更加注重方法的调用顺序，工厂模式注重于创建对象

** 2：创建对象的力度不同，建造者模式创建复杂的对象，由各种复杂的部件组成，工厂模式创建出来的都一样

** 3：关注点：工厂模式只需要把对象创建出来就可以了，而建造者模式中不仅要创建对象，还要知道这个对象由哪些部件组成

** 4：建造者模式根据建造过程中的顺序不一样，最终的对象部件组成也不一样

## 代理模式
代理模式是指为其他对象提供一种代理，以控制对这个对象的访问。

代理对象在客户端和目标对象之间起到中介作用。

属于结构型设计模式

适用场景：保护目标对象，增强目标对象

cglib和jdk动态代理的区别

cglib继承的方式，覆盖父类的方法。

jdk采用的实现方式，必须要求代理的目标对象一定要实现一个接口。

思想：都是通过生成字节码，重组成一个新的类。

JDK Proxy对于用户而言，依赖更强，调用也更复杂。

cglib对目标类没有任何要求。

cglib效率更高，性能也更高，底层没有用到反射。

JDK Proxy生成逻辑较为简单，执行效率要低，每次都用反射

优点：代理模式能将代理对象与真实被调用的目标对象分离。

一定程度上降低了系统的耦合程度，易于扩展。

代理可以起到保护目标对象的作用。

增强目标对象的职责

缺点：代理模式会造成系统设计中类的数目增加。

在客户端和目标对象之间增加了一个代理对象，请求处理速度变慢。

增加了系统的复杂度

spring中代理选择原则：

1：当Bean有实现接口时，spring就会用JDK的动态代理。

2：当Bean没有实现接口时，Spring会选择cglib。

3：spring可以通过配置强制使用cglib，只需要在spring的配置文件中加入如下代码：<aop:aspectj-autoproxy proxy-target-class="true"/>

动态代理和静态代理的区别：
静态代理：硬编码，手动注入，手动拿到目标对象的引用，手动调用代理目标的方法。

动态代理：具有更强的扩展性，自动注入，自动生成一个新的类（同一个继承体系）。

特征：拿到代理目标对象的引用，实现功能增强，保护目标对象

## 门面模式
又叫外观模式，提供了一个统一的接口，用来访问子系统中的一群接口。

特征：门面模式定义了一个高层接口，让子系统更容易使用。

属于结构型模式

适用场景：子系统越来越复杂，增加门面模式提供简单接口，构建多层系统结构，利用门面对象做为每层的入口，简化层间调用 

优点：

1：简化了调用过程，无需深入了解子系统，以防给子系统带来风险

2：减少系统依赖，松散耦合

3：更好地划分访问层次，提高了安全性

4：遵循迪米特法则，即最少知道原则

门面模式和代理模式的区别：

1：门面模式就是特殊的静态代理模式

2：门面模式：重点在于封装

  静态代理：重点在于增强

3：不做增强的静态代理就是门面模式

缺点：

1：当增加子系统和扩展子系统行为时，可能容易带来未知风险

2：不符合开闭原则

3：某些情况下可能违背单一职责原则

## 装饰器模式
装饰器模式也叫包装模式，是指在不改变原有对象的基础之上，将功能附加到对象上，提供了比继承更有弹性的替代方案（扩展原有对象的功能）

属于结构型模式

适用场景：

1：用于扩展一个类的功能或给一个类添加附加职责

2：动态的给一个对象添加功能，这些功能可以再动态的撤销


装饰器模式和代理模式对比：

1：装饰器模式就是一种特殊的代理模式

2：装饰器模式强调自身的功能扩展

3：代理模式强调代理过程的控制

优点：

1：装饰器是继承的有力补充，比继承灵活，不改变原有对象的情=情况下，动态地给一个对象扩展功能，即插即用

2：通过使用不同装饰类以及这些装饰类的排列组合，可实现不同效果

3：装饰器完全遵守开闭原则

缺点：

1：会出现更多的代码，更多的类，增加程序复杂性

2：动态装饰时，多层装饰时会更加复杂


# 享元模式

1：享元模式又称为轻量级模式，是对象池的一种实现，类似于线程池，线程池可以避免不停地创建和销毁多个对象，
   消耗性能，提供了减少对象数量从而改善应用所需的对象结构的方式

2：宗旨：共享细粒度对象，将多个对同一个对象的访问集中起来

3：属于结构型模式

4：适用场景：常常应用于系统底层的开发，以便解决系统的性能问题，
           系统有大量相似对象，需要缓冲池的场景

5：优点：减少对象的创建，降低内存中对象的数量，降低系统的内存，提高效率，减少内存之外的其他资源占用。

6：缺点：关注内，外部状态，关注线程安全问题，使系统，程序的逻辑复杂化

# 组合模式
1：组合模式也称为整体-部分模式，他的宗旨是通过将单个对象（叶子节点）和组合对象（树枝节点）用相同的接口进行表达

2：作用：使客户端对单个对象和组合对象保持一致的方式处理

3：属于结构型模式

4：适用场景：希望客户端可以忽略组合对象与单个对象的差异时，对象层次具备整体和部分，呈树形结构（如树形菜单，操作系统目录结构，公司组织架构等）

5：优点：1：清楚地定义了层次的复杂对象，表示对象的全部或部分层次。
   
2：让客户端忽略了层次的差异，方便对整个层次结构进行控制

3：简化客户端代码

4：符合开闭原则

6：缺点：限制类型时会较为复杂，使设计变得更加抽象

# 适配器模式
1：适配器模式又叫做变压器模式，他的功能是将一个类的接口变成客户端所期望的另一种接口，
   从而使得原本因接口不匹配而导致无法在一起工作的两个类能够在一起工作

2：属于结构型设计模式

3：使用场景：1：已存在的类，他的方法和需求不匹配（方法结果相同或相似）的情况
           2：适配器模式不是阮嘉设计阶段考虑的设计模式，是随着软件维护，由于不同产品，不同厂家造成功能类似而接口不相同的情况下的解决方法

4：优点：1：能提高类的透明性和复用，现有的类复用但不需要改变。
        2：目标类和适配器类解耦，提高程序的扩展性。
        3：在很多业务场景中符合开闭原则

5：缺点：
    1：适配器编写过程需要全面考虑，可能会增加系统的复杂性。
    2：增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱